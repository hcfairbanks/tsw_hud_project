<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Map - TSW HUD Project</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }

        @keyframes recording-glow {
            0%, 100% {
                opacity: 1;
                filter: drop-shadow(0 0 3px #ff0000);
            }
            50% {
                opacity: 0.6;
                filter: drop-shadow(0 0 8px #ff0000) drop-shadow(0 0 12px #ff0000);
            }
        }

        .recording-indicator {
            color: #ff0000;
            display: inline-block;
            animation: recording-glow 1.5s ease-in-out infinite;
        }

        .recording-indicator.paused {
            color: #ffaa00;
            animation: none;
        }

        .recording-indicator.stopped {
            color: #999;
            animation: none;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            bottom: 10px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 320px;
            max-width: 350px;
            overflow-y: auto;
        }

        .info-panel h2 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #0066ff;
            padding-bottom: 10px;
        }

        .info-group {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .info-group h3 {
            font-size: 14px;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 13px;
        }

        .info-label {
            color: #666;
            font-weight: 500;
        }

        .info-value {
            color: #333;
            font-weight: bold;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 5px;
            margin-top: 5px;
        }

        .btn-primary {
            background: #0066ff;
            color: white;
        }

        .btn-primary:hover {
            background: #0052cc;
        }

        .btn-danger {
            background: #dc3545;
            color: #fff;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-success {
            background: #28a745;
            color: #fff;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .timetable-dropdown {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            margin-top: 8px;
            background: white;
            color: #333;
            cursor: pointer;
        }

        .timetable-dropdown:focus {
            outline: none;
            border-color: #0066ff;
        }

        .legend {
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .legend h3 {
            font-size: 14px;
            color: #555;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
            color: #666;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .legend-line {
            width: 20px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .follow-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            width: 100%;
            margin-top: 10px;
        }

        .follow-btn:hover {
            background: #1d4ed8;
        }

        .follow-btn.following {
            background: #dc2626;
        }

        .follow-btn.following:hover {
            background: #b91c1c;
        }

        .nav-link {
            display: inline-block;
            color: #0066ff;
            text-decoration: none;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        .controls-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .position-display {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div class="info-panel">
        <a href="/" class="nav-link">Back to Home</a>
        <h2><span class="recording-indicator stopped" id="recordingIndicator">●</span> <span id="recordingText">Not Recording</span></h2>

        <div class="info-item" style="margin-bottom: 15px;">
            <span class="info-label">Coordinates:</span>
            <span class="info-value" id="coordCount">0</span>
        </div>

        <div class="info-group">
            <div id="timetableSelector" style="margin-bottom: 10px;">
                <label class="info-label">Select Route:</label>
                <select class="timetable-dropdown" id="routeSelect">
                    <option value="">-- Select a route --</option>
                </select>
                <label class="info-label" style="margin-top: 8px;">Select Train:</label>
                <select class="timetable-dropdown" id="trainSelect" disabled>
                    <option value="">-- Select a route first --</option>
                </select>
                <label class="info-label" style="margin-top: 8px;">Select Timetable:</label>
                <select class="timetable-dropdown" id="timetableSelect" disabled>
                    <option value="">-- Select a train first --</option>
                </select>
            </div>
            <div class="controls-row">
                <button class="btn-success" id="mainBtn" onclick="handleMainButton()">Start</button>
                <button class="btn-danger" id="stopBtn" onclick="stopRecording()">Save</button>
                <button class="btn-secondary" id="resetBtn" onclick="resetRecording()">Reset</button>
            </div>
        </div>

        <div class="info-group">
            <h3>Current Position</h3>
            <div class="info-item">
                <span class="info-label">Latitude:</span>
                <span class="info-value position-display" id="currentLat">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Longitude:</span>
                <span class="info-value position-display" id="currentLng">-</span>
            </div>
        </div>

        <div class="info-group">
            <h3>Save Station Position</h3>
            <label class="info-label">Select Station:</label>
            <select class="timetable-dropdown" id="stationDropdown">
                <option value="">-- Start recording first --</option>
            </select>
            <div class="controls-row">
                <button class="btn-success" id="saveBtn" onclick="saveToTimetable()" disabled>Save Position</button>
            </div>
        </div>

        <div class="dev-tools" style="background: rgba(255, 0, 0, 0.15); border: 2px solid rgba(255, 0, 0, 0.4); border-radius: 6px; padding: 12px; margin-bottom: 12px;">
            <h3 style="color: #cc0000; margin: 0 0 10px 0; font-size: 14px;">Development Tools</h3>

            <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 0, 0, 0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleLoadFile()">
                    <label style="font-size: 12px; color: #aaa; font-weight: 600; cursor: pointer;">Load Recording File</label>
                    <span id="loadFileToggle" style="font-size: 12px; color: #aaa;">▼</span>
                </div>
                <div id="loadFileContent" style="margin-top: 10px;">
                    <select class="timetable-dropdown" id="recordingFileSelect">
                        <option value="">-- Loading... --</option>
                    </select>
                    <div class="controls-row">
                        <button class="btn-warning" id="loadFileBtn" onclick="loadSelectedFile()">Load File</button>
                        <input type="file" id="browseFileInput" accept=".json" style="display: none;" onchange="handleFileBrowse(event)">
                        <button class="btn-secondary" onclick="document.getElementById('browseFileInput').click()">Browse...</button>
                    </div>
                    <div id="loadFileStatus" style="margin-top: 8px; font-size: 12px; color: #aaa;"></div>
                </div>
            </div>

            <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 0, 0, 0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleRemakeJson()">
                    <label style="font-size: 12px; color: #aaa; font-weight: 600; cursor: pointer;">Remake JSON from DB</label>
                    <span id="remakeJsonToggle" style="font-size: 12px; color: #aaa;">▼</span>
                </div>
                <div id="remakeJsonContent" style="margin-top: 10px;">
                    <label class="info-label">Select Timetable:</label>
                    <select class="timetable-dropdown" id="remakeTimetableSelect">
                        <option value="">-- Loading... --</option>
                    </select>
                    <div class="controls-row">
                        <button class="btn-danger" id="remakeBtn" onclick="remakeFromDb()">Remake</button>
                    </div>
                    <div id="remakeStatus" style="margin-top: 8px; font-size: 12px; color: #aaa;"></div>
                </div>
            </div>

            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleCoordinatesPicker()">
                    <label style="font-size: 12px; color: #aaa; font-weight: 600; cursor: pointer;">Coordinates Picker</label>
                    <span id="coordsToggle" style="font-size: 12px; color: #aaa;">▼</span>
                </div>
                <div id="coordsPickerContent" style="margin-top: 10px;">
                    <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Click on map to capture coordinates</div>
                    <div id="pickedCoords" style="font-family: 'Courier New', monospace; font-size: 12px; color: #333; background: #f8f9fa; padding: 8px; border-radius: 4px; min-height: 40px; white-space: pre-wrap;">No coordinates selected</div>
                    <div class="controls-row">
                        <button class="btn-primary" onclick="copyPickedCoords(event)">Copy</button>
                        <button class="btn-secondary" onclick="clearPickedCoords()">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="legend">
            <h3>Map Legend</h3>
            <div class="legend-item">
                <div class="legend-line" style="background: #0066ff;"></div>
                <span>Route Path</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffa500;"></div>
                <span>Current Train Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00cc66;"></div>
                <span>Saved Station</span>
            </div>
            <button class="follow-btn" id="followBtn" onclick="toggleFollowTrain()">Follow Train</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize the map
        const map = L.map('map').setView([52.0, -0.5], 10);

        // Add tile layers
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        });
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri',
            maxZoom: 19
        });
        osm.addTo(map);
        L.control.layers({ 'Geographic': osm, 'Satellite': satellite }).addTo(map);

        // State
        let pathCoordinates = [];
        let pathPolyline = null;
        let trainMarker = null;
        let stationMarkers = new Map();
        let isFollowingTrain = false;
        let firstPosition = true;
        let currentTimetableId = null;
        let nextStationIndex = null; // Used to advance dropdown after save

        // Create custom train icon
        const trainIcon = L.divIcon({
            className: 'train-icon',
            html: '<div style="background: #ffa500; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(255,165,0,0.8), 0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        // Store all timetables for filtering
        let allTimetables = [];

        // Load routes that have timetables for selector
        async function loadRoutesWithTimetables() {
            try {
                // Load all timetables first
                const timetablesResponse = await fetch('/api/timetables');
                allTimetables = await timetablesResponse.json();

                // Get unique route IDs that have timetables
                const routeIdsWithTimetables = [...new Set(allTimetables.map(t => t.route_id))];

                if (routeIdsWithTimetables.length === 0) {
                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '<option value="">-- No routes with timetables --</option>';
                    return;
                }

                // Load all routes
                const routesResponse = await fetch('/api/routes');
                const allRoutes = await routesResponse.json();

                // Filter to only routes that have timetables
                const routesWithTimetables = allRoutes.filter(r => routeIdsWithTimetables.includes(r.id));

                const routeSelect = document.getElementById('routeSelect');
                routeSelect.innerHTML = '<option value="">-- Select a route --</option>';
                routesWithTimetables.forEach(r => {
                    const option = document.createElement('option');
                    option.value = r.id;
                    option.textContent = r.name;
                    routeSelect.appendChild(option);
                });
            } catch (err) {
                console.error('Failed to load routes:', err);
            }
        }

        // Load trains for selected route
        async function loadTrainsForRoute(routeId) {
            const trainSelect = document.getElementById('trainSelect');
            const timetableSelect = document.getElementById('timetableSelect');

            // Reset train and timetable dropdowns
            trainSelect.innerHTML = '<option value="">-- Loading... --</option>';
            trainSelect.disabled = true;
            timetableSelect.innerHTML = '<option value="">-- Select a train first --</option>';
            timetableSelect.disabled = true;

            if (!routeId) {
                trainSelect.innerHTML = '<option value="">-- Select a route first --</option>';
                return;
            }

            // Get unique train IDs from timetables for this route
            const timetablesForRoute = allTimetables.filter(t => t.route_id == routeId);
            const trainIdsForRoute = [...new Set(timetablesForRoute.map(t => t.train_id))];

            if (trainIdsForRoute.length === 0) {
                trainSelect.innerHTML = '<option value="">-- No trains for this route --</option>';
                return;
            }

            try {
                // Load all trains
                const trainsResponse = await fetch('/api/trains');
                const allTrains = await trainsResponse.json();

                // Filter to trains that have timetables on this route
                const trainsForRoute = allTrains.filter(t => trainIdsForRoute.includes(t.id));

                trainSelect.innerHTML = '<option value="">-- Select a train --</option>';
                trainsForRoute.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.name;
                    trainSelect.appendChild(option);
                });
                trainSelect.disabled = false;
            } catch (err) {
                console.error('Failed to load trains:', err);
                trainSelect.innerHTML = '<option value="">-- Error loading trains --</option>';
            }
        }

        // Load timetables for selected route and train
        function loadTimetablesForRouteAndTrain(routeId, trainId) {
            const timetableSelect = document.getElementById('timetableSelect');

            if (!routeId || !trainId) {
                timetableSelect.innerHTML = '<option value="">-- Select a train first --</option>';
                timetableSelect.disabled = true;
                return;
            }

            // Filter timetables for this route and train
            const timetables = allTimetables.filter(t => t.route_id == routeId && t.train_id == trainId);

            if (timetables.length === 0) {
                timetableSelect.innerHTML = '<option value="">-- No timetables found --</option>';
                timetableSelect.disabled = true;
                return;
            }

            timetableSelect.innerHTML = '<option value="">-- Select a timetable --</option>';
            timetables.forEach(t => {
                const option = document.createElement('option');
                option.value = t.id;
                option.textContent = t.service_name;
                timetableSelect.appendChild(option);
            });
            timetableSelect.disabled = false;
        }

        // Event listeners for cascading dropdowns
        document.getElementById('routeSelect').addEventListener('change', function() {
            const routeId = this.value;
            loadTrainsForRoute(routeId);
            document.getElementById('mainBtn').textContent = 'Start';
        });

        document.getElementById('trainSelect').addEventListener('change', function() {
            const routeId = document.getElementById('routeSelect').value;
            const trainId = this.value;
            loadTimetablesForRouteAndTrain(routeId, trainId);
            document.getElementById('mainBtn').textContent = 'Start';
        });


        // Load route data (called at init and after saves to sync with backend state)
        async function loadRouteData() {
            try {
                const response = await fetch('/api/recording/route-data');
                const data = await response.json();

                // Load existing path from backend (only at init or after resume)
                if (data.coordinates && data.coordinates.length > 0) {
                    pathCoordinates = data.coordinates.map(c => [c.latitude, c.longitude]);
                    document.getElementById('coordCount').textContent = pathCoordinates.length;

                    if (pathPolyline) {
                        pathPolyline.setLatLngs(pathCoordinates);
                    } else {
                        pathPolyline = L.polyline(pathCoordinates, {
                            color: '#0066ff',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                    }

                    // Center on last known position
                    if (firstPosition && pathCoordinates.length > 0) {
                        const last = pathCoordinates[pathCoordinates.length - 1];
                        map.setView(last, 15);
                        firstPosition = false;
                    }
                }

                // Populate station dropdown and add saved station markers
                if (data.timetable && data.timetable.length > 0) {
                    // Select next unsaved station on initial load
                    populateStationDropdown(data.timetable, true);

                    // Add markers for stations with saved coordinates
                    data.timetable.forEach((entry, index) => {
                        if (entry.latitude && entry.longitude) {
                            addStationMarker(index, entry.latitude, entry.longitude, entry.destination);
                        }
                    });
                }
            } catch (err) {
                console.error('Failed to load route data:', err);
            }
        }

        // Populate station dropdown - preserves current selection or selects next unsaved
        function populateStationDropdown(timetable, selectNextUnsaved = false) {
            const dropdown = document.getElementById('stationDropdown');
            const currentValue = dropdown.value; // Preserve current selection

            dropdown.innerHTML = '';
            let firstUnsavedIndex = null;

            timetable.forEach((entry, index) => {
                const option = document.createElement('option');
                option.value = index;
                const hasCoords = entry.latitude && entry.longitude;
                option.textContent = `${index + 1}. ${entry.destination}${hasCoords ? ' [SAVED]' : ''}`;
                dropdown.appendChild(option);

                // Track the first unsaved station
                if (firstUnsavedIndex === null && !hasCoords) {
                    firstUnsavedIndex = index;
                }
            });

            // If we need to advance to next station after a save
            if (nextStationIndex !== null && nextStationIndex < timetable.length) {
                dropdown.value = nextStationIndex;
                nextStationIndex = null; // Reset the flag
            }
            // If explicitly selecting next unsaved (e.g., on initial load)
            else if (selectNextUnsaved && firstUnsavedIndex !== null) {
                dropdown.value = firstUnsavedIndex;
            }
            // Otherwise restore previous selection if it was valid
            else if (currentValue !== '' && currentValue !== null && parseInt(currentValue) < timetable.length) {
                dropdown.value = currentValue;
            }
            // Default: select the first unsaved if no previous selection
            else if (firstUnsavedIndex !== null) {
                dropdown.value = firstUnsavedIndex;
            }
        }

        // Add station marker to map
        function addStationMarker(index, lat, lng, destination) {
            if (stationMarkers.has(index)) {
                map.removeLayer(stationMarkers.get(index));
            }

            const stationIcon = L.divIcon({
                className: 'station-marker',
                html: '<div style="background-color: #00cc66; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });

            const marker = L.marker([lat, lng], { icon: stationIcon })
                .bindPopup(`<strong>${index + 1}. ${destination}</strong><br>Lat: ${lat}<br>Lng: ${lng}`)
                .addTo(map);

            stationMarkers.set(index, marker);
        }

        // Main button handler - handles Start, Resume, and Pause states
        // Button states:
        // - "Start": No recording, no incomplete file - starts fresh recording
        // - "Resume": No recording, but incomplete file exists - resumes from file
        // - "Pause": Recording is active - pauses the recording
        // - "Resume": Recording is paused - resumes the paused recording
        async function handleMainButton() {
            const mainBtn = document.getElementById('mainBtn');
            const btnText = mainBtn.textContent;

            console.log(`Main button clicked: "${btnText}", state: ${currentRecordingState}`);

            // If recording is active (button shows "Pause"), pause the recording
            if (currentRecordingState === 'recording') {
                try {
                    const response = await fetch('/api/recording/pause', { method: 'POST' });
                    const result = await response.json();
                    if (!result.success) {
                        alert('Failed to pause: ' + result.error);
                    }
                    // Stream will update the UI
                } catch (err) {
                    alert('Error pausing: ' + err.message);
                }
                return;
            }

            // If recording is paused, resume it
            if (currentRecordingState === 'paused') {
                try {
                    const response = await fetch('/api/recording/resume', { method: 'POST' });
                    const result = await response.json();
                    if (!result.success) {
                        alert('Failed to resume: ' + result.error);
                    }
                    // Stream will update the UI
                } catch (err) {
                    alert('Error resuming: ' + err.message);
                }
                return;
            }

            // Otherwise, we're starting or resuming from file (state is 'stopped')
            const timetableId = document.getElementById('timetableSelect').value;
            if (!timetableId) {
                alert('Please select a timetable first');
                return;
            }

            const isResumeFromFile = btnText === 'Resume';

            try {
                const response = await fetch(`/api/recording/start/${timetableId}`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    if (isResumeFromFile) {
                        // Resuming from file - show popup and DON'T clear existing data
                        alert(`Recording resumed!\n\nExisting data: ${result.coordinateCount} coordinates, ${result.markerCount} markers\n\nNew coordinates will be added to the recording.`);
                    } else {
                        // Fresh start - clear local display
                        pathCoordinates = [];
                        if (pathPolyline) {
                            map.removeLayer(pathPolyline);
                            pathPolyline = null;
                        }
                        // Clear station markers
                        stationMarkers.forEach(m => map.removeLayer(m));
                        stationMarkers.clear();
                    }
                    // Stream will update the rest

                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                } else {
                    alert('Failed to start recording: ' + result.error);
                }
            } catch (err) {
                alert('Error starting recording: ' + err.message);
            }
        }

        // Track current recording state for button logic
        // 'stopped' = not recording (can start fresh or resume from file)
        // 'recording' = actively recording (can pause)
        // 'paused' = recording paused (can resume)
        let currentRecordingState = 'stopped';

        // Stop recording, process file, and save to database
        async function stopRecording() {
            const stopBtn = document.getElementById('stopBtn');
            stopBtn.disabled = true;
            stopBtn.textContent = 'Stopping...';

            try {
                // Step 1: Stop the recording (if still running/paused)
                // This ensures the raw JSON file is finalized
                const stopResponse = await fetch('/api/recording/stop', { method: 'POST' });
                const stopResult = await stopResponse.json();

                // It's okay if stop fails (e.g., already stopped) - we can still try to process
                if (stopResult.success) {
                    console.log('Recording stopped:', stopResult);
                } else {
                    console.log('Stop returned:', stopResult.error || 'no active recording');
                }

                // Step 2: Process the raw recording into processed JSON
                stopBtn.textContent = 'Processing...';

                const processResponse = await fetch('/api/route-processing/process-latest', { method: 'POST' });
                const processResult = await processResponse.json();

                if (!processResult.success) {
                    throw new Error(processResult.error || 'Failed to process recording');
                }

                console.log('Recording processed:', processResult);

                // Step 3: Save the processed JSON to the database
                stopBtn.textContent = 'Saving to DB...';

                const saveResponse = await fetch('/api/map/save-processed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: processResult.outputFile })
                });

                const saveResult = await saveResponse.json();

                if (!saveResult.success) {
                    throw new Error(saveResult.error || 'Failed to save to database');
                }

                console.log('Saved to database:', saveResult);

                alert(`Processing and save complete!\n\n` +
                    `Output: ${processResult.outputFile}\n` +
                    `Coordinates: ${saveResult.coordinateCount}\n` +
                    `Markers: ${saveResult.markerCount}\n` +
                    `Entry updates: ${saveResult.entryUpdates}`);

                // Refresh recording files dropdown
                await loadRecordingFiles();

            } catch (err) {
                console.error('Error processing/saving recording:', err);
                alert('Error: ' + err.message);
            } finally {
                stopBtn.textContent = 'Save';
                stopBtn.disabled = false;
            }
        }

        // Reset recording - clears all state for testing
        async function resetRecording() {
            if (!confirm('Reset all recording state? This will clear coordinates, markers, and saved positions.')) {
                return;
            }

            try {
                const response = await fetch('/api/recording/reset', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // Clear local state
                    pathCoordinates = [];
                    if (pathPolyline) {
                        map.removeLayer(pathPolyline);
                        pathPolyline = null;
                    }
                    // Clear station markers
                    stationMarkers.forEach(m => map.removeLayer(m));
                    stationMarkers.clear();
                    // Reset UI
                    currentTimetableId = null;
                    currentRecordingState = 'stopped';
                    document.getElementById('coordCount').textContent = '0';
                    document.getElementById('stationDropdown').innerHTML = '<option value="">-- Start recording first --</option>';
                    // Reset all cascading dropdowns
                    document.getElementById('routeSelect').value = '';
                    document.getElementById('trainSelect').innerHTML = '<option value="">-- Select a route first --</option>';
                    document.getElementById('trainSelect').disabled = true;
                    document.getElementById('timetableSelect').innerHTML = '<option value="">-- Select a train first --</option>';
                    document.getElementById('timetableSelect').disabled = true;
                    // Reset main button
                    const mainBtn = document.getElementById('mainBtn');
                    mainBtn.textContent = 'Start';
                    mainBtn.className = 'btn-success';
                    mainBtn.disabled = false;
                    // Reset dev tools status
                    const statusEl = document.getElementById('loadFileStatus');
                    if (statusEl) {
                        statusEl.textContent = '';
                    }
                    // Update UI state
                    updateUIFromRecording({ isRecording: false, isPaused: false });
                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                    console.log('Recording state reset');
                } else {
                    alert('Failed to reset: ' + result.error);
                }
            } catch (err) {
                alert('Error resetting: ' + err.message);
            }
        }

        // Save current position to timetable
        async function saveToTimetable() {
            const index = parseInt(document.getElementById('stationDropdown').value);
            const latEl = document.getElementById('currentLat');
            const lngEl = document.getElementById('currentLng');

            // Use full precision values stored in dataset, not truncated display text
            const lat = latEl.dataset.fullValue;
            const lng = lngEl.dataset.fullValue;

            if (!lat || !lng || latEl.textContent === '-') {
                alert('No current position available');
                return;
            }

            try {
                const response = await fetch('/api/recording/save-timetable-coords', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        index: index,
                        latitude: parseFloat(lat),
                        longitude: parseFloat(lng)
                    })
                });
                const result = await response.json();
                if (result.success) {
                    // Set flag to advance to next station
                    const dropdown = document.getElementById('stationDropdown');
                    if (index + 1 < dropdown.options.length) {
                        nextStationIndex = index + 1;
                    }
                    // Stream will update the timetable with saved coords
                } else {
                    alert('Failed to save: ' + result.error);
                }
            } catch (err) {
                alert('Error saving: ' + err.message);
            }
        }

        // Toggle follow train
        function toggleFollowTrain() {
            const btn = document.getElementById('followBtn');
            isFollowingTrain = !isFollowingTrain;

            if (isFollowingTrain) {
                btn.textContent = 'Stop Following';
                btn.classList.add('following');
                if (trainMarker) {
                    const pos = trainMarker.getLatLng();
                    map.setView([pos.lat, pos.lng], map.getZoom());
                }
            } else {
                btn.textContent = 'Follow Train';
                btn.classList.remove('following');
            }
        }

        // SSE stream connection
        let eventSource = null;

        function connectToStream() {
            if (eventSource) {
                eventSource.close();
            }

            console.log('Connecting to telemetry stream...');
            eventSource = new EventSource('/stream');

            eventSource.onopen = () => {
                console.log('SSE connection established');
            };

            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleStreamData(data);
                } catch (err) {
                    console.error('Failed to parse stream data:', err);
                }
            };

            eventSource.onerror = (err) => {
                console.error('SSE connection error:', err);
                // Reconnect after 2 seconds
                setTimeout(connectToStream, 2000);
            };
        }

        // Handle incoming stream data
        function handleStreamData(data) {
            // Update current position display
            if (data.playerPosition) {
                const lat = data.playerPosition.latitude;
                const lng = data.playerPosition.longitude;

                // Store full precision for saving, display truncated
                document.getElementById('currentLat').textContent = lat.toFixed(6);
                document.getElementById('currentLng').textContent = lng.toFixed(6);
                document.getElementById('currentLat').dataset.fullValue = lat;
                document.getElementById('currentLng').dataset.fullValue = lng;

                // Update train marker
                if (trainMarker) {
                    trainMarker.setLatLng([lat, lng]);
                } else {
                    trainMarker = L.marker([lat, lng], { icon: trainIcon })
                        .bindPopup('Current Position')
                        .addTo(map);
                }

                // Add to path display if recording (for visual feedback)
                // The backend is the source of truth, we just add points for smooth display
                if (currentTimetableId && data.recording && data.recording.isRecording && !data.recording.isPaused) {
                    const newPoint = [lat, lng];
                    pathCoordinates.push(newPoint);

                    if (pathPolyline) {
                        pathPolyline.addLatLng(newPoint);
                    } else {
                        pathPolyline = L.polyline(pathCoordinates, {
                            color: '#0066ff',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                    }
                }

                // Center on first position or follow train
                if (firstPosition) {
                    map.setView([lat, lng], 15);
                    firstPosition = false;
                } else if (isFollowingTrain) {
                    map.setView([lat, lng], map.getZoom());
                }
            }

            // Update recording state from stream
            if (data.recording) {
                currentTimetableId = data.recording.timetableId;
                document.getElementById('coordCount').textContent = data.recording.coordinateCount || 0;

                // Update UI state
                updateUIFromRecording(data.recording);

                // Update timetable dropdown and station markers
                if (data.recording.timetable && data.recording.timetable.length > 0) {
                    populateStationDropdown(data.recording.timetable);

                    // Add markers for stations with saved coordinates
                    data.recording.timetable.forEach((entry, index) => {
                        if (entry.latitude && entry.longitude) {
                            addStationMarker(index, entry.latitude, entry.longitude, entry.destination);
                        }
                    });
                }
            } else if (currentTimetableId) {
                // Recording stopped - clear state
                currentTimetableId = null;
                updateUIFromRecording({ isRecording: false, isPaused: false });
            }
        }

        // Update UI based on recording state from stream
        function updateUIFromRecording(recording) {
            const indicator = document.getElementById('recordingIndicator');
            const text = document.getElementById('recordingText');
            const mainBtn = document.getElementById('mainBtn');
            const stopBtn = document.getElementById('stopBtn');
            const saveBtn = document.getElementById('saveBtn');

            if (recording.isRecording && !recording.isPaused) {
                // Recording is active
                currentRecordingState = 'recording';
                indicator.className = 'recording-indicator';
                text.textContent = 'Recording';
                mainBtn.textContent = 'Pause';
                mainBtn.className = 'btn-warning';
                mainBtn.disabled = false;
                stopBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
            } else if (recording.isPaused) {
                // Recording is paused
                currentRecordingState = 'paused';
                indicator.className = 'recording-indicator paused';
                text.textContent = 'Paused';
                mainBtn.textContent = 'Resume';
                mainBtn.className = 'btn-success';
                mainBtn.disabled = false;
                stopBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
            } else {
                // Not recording - check if there's an incomplete file to resume
                currentRecordingState = 'stopped';
                indicator.className = 'recording-indicator stopped';
                text.textContent = 'Not Recording';
                // Button text (Start vs Resume) is set by checkForExistingRecording
                // Keep current text if it's already "Resume", otherwise default to "Start"
                if (mainBtn.textContent !== 'Resume') {
                    mainBtn.textContent = 'Start';
                }
                mainBtn.className = 'btn-success';
                mainBtn.disabled = false;
                stopBtn.disabled = true;
                if (saveBtn) saveBtn.disabled = true;
            }
        }

        // Load timetables for remake dropdown
        async function loadRemakeTimetables() {
            const select = document.getElementById('remakeTimetableSelect');
            select.innerHTML = '<option value="">-- Loading... --</option>';

            try {
                const response = await fetch('/api/timetables');
                const timetables = await response.json();

                select.innerHTML = '<option value="">-- Select a timetable --</option>';
                timetables.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.service_name;
                    select.appendChild(option);
                });

                if (timetables.length === 0) {
                    select.innerHTML = '<option value="">-- No timetables found --</option>';
                }
            } catch (err) {
                console.error('Failed to load timetables for remake:', err);
                select.innerHTML = '<option value="">-- Error loading --</option>';
            }
        }

        // Remake JSON from database
        async function remakeFromDb() {
            const select = document.getElementById('remakeTimetableSelect');
            const timetableId = select.value;
            const statusEl = document.getElementById('remakeStatus');

            if (!timetableId) {
                statusEl.textContent = 'Please select a timetable first';
                statusEl.style.color = '#e94560';
                return;
            }

            const remakeBtn = document.getElementById('remakeBtn');
            remakeBtn.disabled = true;
            statusEl.textContent = 'Remaking...';
            statusEl.style.color = '#aaa';

            try {
                const response = await fetch('/api/map/remake', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timetableId: parseInt(timetableId) })
                });

                const result = await response.json();

                if (result.success) {
                    statusEl.innerHTML = `<span style="color: #28a745;">Created!</span> ` +
                        `${result.filename}<br>` +
                        `Coords: ${result.stats.coordinates}, ` +
                        `Markers: ${result.stats.markers}, ` +
                        `Entries: ${result.stats.timetableEntries}`;
                } else {
                    statusEl.textContent = 'Error: ' + result.error;
                    statusEl.style.color = '#e94560';
                }
            } catch (err) {
                console.error('Failed to remake JSON:', err);
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e94560';
            } finally {
                remakeBtn.disabled = false;
            }
        }

        // Load config and hide dev tools if needed
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                if (!config.developmentMode) {
                    const devTools = document.querySelector('.dev-tools');
                    if (devTools) {
                        devTools.style.display = 'none';
                    }
                }
            } catch (err) {
                console.error('Failed to load config:', err);
            }
        }

        // Load recording files list for the dev tools dropdown
        async function loadRecordingFiles() {
            const select = document.getElementById('recordingFileSelect');
            select.innerHTML = '<option value="">-- Loading... --</option>';

            try {
                const response = await fetch('/api/recording/list');
                const files = await response.json();

                select.innerHTML = '<option value="">-- Select a file --</option>';
                files.forEach(f => {
                    const option = document.createElement('option');
                    option.value = f.filename;
                    option.textContent = `${f.routeName} (${f.coordinateCount} pts) - ${f.filename}`;
                    select.appendChild(option);
                });

                if (files.length === 0) {
                    select.innerHTML = '<option value="">-- No recording files --</option>';
                }
            } catch (err) {
                console.error('Failed to load recording files:', err);
                select.innerHTML = '<option value="">-- Error loading --</option>';
            }
        }

        // Load selected file from dropdown
        async function loadSelectedFile() {
            const select = document.getElementById('recordingFileSelect');
            const filename = select.value;
            const statusEl = document.getElementById('loadFileStatus');

            if (!filename) {
                statusEl.textContent = 'Please select a file first';
                statusEl.style.color = '#e94560';
                return;
            }

            await loadRecordingFileByName(filename);
        }

        // Handle file browse input
        async function handleFileBrowse(event) {
            const file = event.target.files[0];
            if (!file) return;

            const statusEl = document.getElementById('loadFileStatus');
            statusEl.textContent = 'Reading file...';
            statusEl.style.color = '#aaa';

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.timetableId) {
                    statusEl.textContent = 'Error: File does not contain timetableId';
                    statusEl.style.color = '#e94560';
                    return;
                }

                // Upload the file to the server first, then load it
                // For now, we'll use the file directly if it matches an existing file
                // or show an error
                statusEl.textContent = `File: ${file.name} (timetable ${data.timetableId})`;
                statusEl.style.color = '#28a745';

                // Check if this file exists on server
                const response = await fetch(`/api/recording/file?file=${encodeURIComponent(file.name)}`);
                if (response.ok) {
                    await loadRecordingFileByName(file.name);
                } else {
                    statusEl.innerHTML = `<span style="color: #ffc107;">File not on server.</span> Copy to recording_data folder first.`;
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e94560';
            }

            // Reset file input
            event.target.value = '';
        }

        // Load a recording file by name
        async function loadRecordingFileByName(filename) {
            const statusEl = document.getElementById('loadFileStatus');
            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#aaa';

            try {
                const response = await fetch(`/api/recording/load-file?file=${encodeURIComponent(filename)}`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    statusEl.innerHTML = `<span style="color: #28a745;">Loaded!</span> ${result.coordinateCount} coords, ${result.markerCount} markers`;

                    // Update the cascading dropdowns to match the timetable
                    await selectTimetableById(result.timetableId);

                    // Update Start button to show Resume
                    document.getElementById('mainBtn').textContent = 'Resume';

                    // Load the route data to display on map
                    await loadRouteData();

                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                } else {
                    statusEl.textContent = 'Error: ' + result.error;
                    statusEl.style.color = '#e94560';
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e94560';
            }
        }

        // Check for existing recording when timetable is selected
        async function checkForExistingRecording(timetableId) {
            if (!timetableId) return;

            try {
                const response = await fetch(`/api/recording/check-existing/${timetableId}`);
                const result = await response.json();

                const mainBtn = document.getElementById('mainBtn');

                if (result.exists) {
                    mainBtn.textContent = 'Resume';
                    console.log(`Found existing recording: ${result.filename} with ${result.coordinateCount} coordinates`);
                } else {
                    mainBtn.textContent = 'Start';
                }
            } catch (err) {
                console.error('Error checking for existing recording:', err);
            }
        }

        // Add event listener for timetable select change
        document.getElementById('timetableSelect').addEventListener('change', function() {
            const timetableId = this.value;
            if (timetableId) {
                checkForExistingRecording(timetableId);
            } else {
                document.getElementById('mainBtn').textContent = 'Start';
            }
        });

        // Helper to select route/train/timetable by timetable ID
        async function selectTimetableById(timetableId) {
            // Find the timetable in our cached list
            const timetable = allTimetables.find(t => t.id == timetableId);
            if (!timetable) return false;

            // Set route dropdown and trigger train load
            const routeSelect = document.getElementById('routeSelect');
            routeSelect.value = timetable.route_id;
            await loadTrainsForRoute(timetable.route_id);

            // Set train dropdown and trigger timetable load
            const trainSelect = document.getElementById('trainSelect');
            trainSelect.value = timetable.train_id;
            loadTimetablesForRouteAndTrain(timetable.route_id, timetable.train_id);

            // Set timetable dropdown
            const timetableSelect = document.getElementById('timetableSelect');
            timetableSelect.value = timetableId;

            return true;
        }

        // Check for any existing recording file and auto-load it
        async function checkAndLoadExistingRecording() {
            try {
                const response = await fetch('/api/recording/check-any-existing');
                const result = await response.json();

                if (result.exists && result.filename) {
                    console.log(`Found existing recording: ${result.filename}`);
                    console.log(`  Route: ${result.routeName}, Coords: ${result.coordinateCount}, Markers: ${result.markerCount}`);

                    // Auto-load the file
                    const loadResponse = await fetch(`/api/recording/load-file?file=${encodeURIComponent(result.filename)}`, {
                        method: 'POST'
                    });
                    const loadResult = await loadResponse.json();

                    if (loadResult.success) {
                        // Update the cascading dropdowns to match the timetable
                        await selectTimetableById(loadResult.timetableId);

                        // Update Start button to show Resume
                        document.getElementById('mainBtn').textContent = 'Resume';

                        // Update dev tools status
                        const statusEl = document.getElementById('loadFileStatus');
                        if (statusEl) {
                            statusEl.innerHTML = `<span style="color: #28a745;">Auto-loaded:</span> ${result.filename}`;
                        }

                        console.log(`Auto-loaded recording: ${loadResult.coordinateCount} coords, ${loadResult.markerCount} markers`);
                        return true;
                    }
                }
                return false;
            } catch (err) {
                console.error('Error checking for existing recording:', err);
                return false;
            }
        }

        // Coordinates picker state
        let pickedLat = null;
        let pickedLng = null;
        let coordsPickerMarker = null;

        // Toggle load file section visibility
        function toggleLoadFile() {
            const content = document.getElementById('loadFileContent');
            const toggle = document.getElementById('loadFileToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle remake JSON section visibility
        function toggleRemakeJson() {
            const content = document.getElementById('remakeJsonContent');
            const toggle = document.getElementById('remakeJsonToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle coordinates picker visibility
        function toggleCoordinatesPicker() {
            const content = document.getElementById('coordsPickerContent');
            const toggle = document.getElementById('coordsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Map click handler for coordinates picker
        function setupCoordinatesPicker() {
            map.on('click', function(e) {
                pickedLat = e.latlng.lat;
                pickedLng = e.latlng.lng;
                updatePickedCoords();

                // Add or move marker
                if (coordsPickerMarker) {
                    coordsPickerMarker.setLatLng(e.latlng);
                } else {
                    const pickerIcon = L.divIcon({
                        className: 'picker-marker',
                        html: '<div style="background: #ff00ff; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 8px rgba(255,0,255,0.6);"></div>',
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    });
                    coordsPickerMarker = L.marker(e.latlng, { icon: pickerIcon }).addTo(map);
                }
            });
        }

        // Update picked coordinates display
        function updatePickedCoords() {
            const display = document.getElementById('pickedCoords');
            if (pickedLat !== null && pickedLng !== null) {
                display.textContent = `Latitude: ${pickedLat}\nLongitude: ${pickedLng}`;
            } else {
                display.textContent = 'No coordinates selected';
            }
        }

        // Copy picked coordinates in JSON format
        function copyPickedCoords(e) {
            if (pickedLat === null || pickedLng === null) {
                alert('No coordinates to copy. Click on the map first.');
                return;
            }
            const text = `"longitude": ${pickedLng},\n"latitude": ${pickedLat},`;
            const btn = e ? e.target : document.querySelector('#coordsPickerContent .btn-primary');
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback - still show success if text was likely copied
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
            });
        }

        // Clear picked coordinates
        function clearPickedCoords() {
            pickedLat = null;
            pickedLng = null;
            updatePickedCoords();
            if (coordsPickerMarker) {
                map.removeLayer(coordsPickerMarker);
                coordsPickerMarker = null;
            }
        }

        // Initialize
        async function initialize() {
            await loadRoutesWithTimetables();

            // Setup coordinates picker click handler
            setupCoordinatesPicker();

            // Check for any existing recording file and auto-load it
            const hasExisting = await checkAndLoadExistingRecording();

            // Load existing recording data if any (for path display)
            await loadRouteData();

            // Load timetables for remake dropdown
            await loadRemakeTimetables();

            // Load recording files for dev tools
            await loadRecordingFiles();

            // Load config to hide dev tools if needed
            await loadConfig();

            // Check URL parameters for pre-selected timetable
            const urlParams = new URLSearchParams(window.location.search);
            const routeId = urlParams.get('route_id');
            const trainId = urlParams.get('train_id');

            // If we have route/train params, try to find a matching timetable
            if (routeId || trainId) {
                // Find timetables that match the route/train
                const timetableSelect = document.getElementById('timetableSelect');
                // The select is already populated, we could filter or highlight matching ones
                // For now, just log
                console.log(`Record map opened with route_id=${routeId}, train_id=${trainId}`);
            }

            // Connect to stream - all state updates come from here
            connectToStream();
        }

        initialize();
    </script>
</body>
</html>

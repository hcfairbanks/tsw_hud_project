<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Map - TSW HUD Project</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }

        @keyframes recording-glow {
            0%, 100% {
                opacity: 1;
                filter: drop-shadow(0 0 3px #ff0000);
            }
            50% {
                opacity: 0.6;
                filter: drop-shadow(0 0 8px #ff0000) drop-shadow(0 0 12px #ff0000);
            }
        }

        .recording-indicator {
            color: #ff0000;
            display: inline-block;
            animation: recording-glow 1.5s ease-in-out infinite;
        }

        .recording-indicator.paused {
            color: #ffaa00;
            animation: none;
        }

        .recording-indicator.stopped {
            color: #999;
            animation: none;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            bottom: 10px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 320px;
            max-width: 350px;
            overflow-y: auto;
        }

        .info-panel h2 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #0066ff;
            padding-bottom: 10px;
        }

        .info-group {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .info-group h3 {
            font-size: 14px;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 13px;
        }

        .info-label {
            color: #666;
            font-weight: 500;
        }

        .info-value {
            color: #333;
            font-weight: bold;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 5px;
            margin-top: 5px;
        }

        .btn-primary {
            background: #0066ff;
            color: white;
        }

        .btn-primary:hover {
            background: #0052cc;
        }

        .btn-danger {
            background: #dc3545;
            color: #fff;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-success {
            background: #28a745;
            color: #fff;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-secondary {
            background: #6c757d;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .timetable-dropdown {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            margin-top: 8px;
            background: white;
            color: #333;
            cursor: pointer;
        }

        .timetable-dropdown:focus {
            outline: none;
            border-color: #0066ff;
        }

        .typeahead-container {
            position: relative;
            width: 100%;
        }

        .typeahead-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            margin-top: 8px;
            background: white;
            color: #333;
        }

        .typeahead-input:focus {
            outline: none;
            border-color: #0066ff;
        }

        .typeahead-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            z-index: 1001;
        }

        .typeahead-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #eee;
        }

        .typeahead-item:last-child {
            border-bottom: none;
        }

        .typeahead-item:hover,
        .typeahead-item.highlighted {
            background: #f0f0f0;
        }

        .typeahead-item .route-name {
            font-weight: 600;
            color: #333;
        }

        .typeahead-item .country-name {
            font-size: 11px;
            color: #666;
        }

        .legend {
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .legend h3 {
            font-size: 14px;
            color: #555;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
            color: #666;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .legend-line {
            width: 20px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
        }

        .follow-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            width: 100%;
            margin-top: 10px;
        }

        .follow-btn:hover {
            background: #1d4ed8;
        }

        .follow-btn.following {
            background: #dc2626;
        }

        .follow-btn.following:hover {
            background: #b91c1c;
        }

        .nav-link {
            display: inline-block;
            color: #0066ff;
            text-decoration: none;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        .controls-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .position-display {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div class="info-panel">
        <a href="/" class="nav-link">Back to Home</a>
        <h2><span class="recording-indicator stopped" id="recordingIndicator">●</span> <span id="recordingText">Not Recording</span></h2>

        <div class="info-item" style="margin-bottom: 15px;">
            <span class="info-label">Coordinates:</span>
            <span class="info-value" id="coordCount">0</span>
        </div>

        <div class="info-group">
            <div id="timetableSelector" style="margin-bottom: 10px;">
                <label class="info-label">Select Route:</label>
                <div class="typeahead-container">
                    <input type="text" class="typeahead-input" id="routeInput" placeholder="Type to search routes..." autocomplete="off">
                    <div id="routeDropdown" class="typeahead-dropdown"></div>
                    <input type="hidden" id="routeSelect" value="">
                </div>
                <label class="info-label" style="margin-top: 8px;">Select Train Class:</label>
                <select class="timetable-dropdown" id="trainClassSelect" disabled>
                    <option value="">-- Select a route first --</option>
                </select>
                <label class="info-label" style="margin-top: 8px;">Select Train:</label>
                <select class="timetable-dropdown" id="trainSelect" disabled>
                    <option value="">-- Select a train class first --</option>
                </select>
                <label class="info-label" style="margin-top: 8px;">Select Timetable:</label>
                <select class="timetable-dropdown" id="timetableSelect" disabled>
                    <option value="">-- Select a train first --</option>
                </select>
            </div>
            <div class="controls-row">
                <button class="btn-success" id="mainBtn" onclick="handleMainButton()">Start</button>
                <button class="btn-danger" id="stopBtn" onclick="stopRecording()">Save</button>
                <button class="btn-secondary" id="resetBtn" onclick="resetRecording()">Reset</button>
            </div>
        </div>

        <div class="info-group">
            <h3>Recording Mode</h3>
            <div style="display: flex; gap: 15px; margin-bottom: 5px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="recordMode" value="manual" onchange="handleModeChange(this.value)" style="margin-right: 5px;">
                    Manual
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="radio" name="recordMode" value="automatic" checked onchange="handleModeChange(this.value)" style="margin-right: 5px;">
                    Automatic
                </label>
            </div>
            <div id="autoModeInfo" style="font-size: 11px; color: #666;">
                Auto-stops after 4 min of no movement
            </div>
        </div>

        <div class="info-group">
            <h3>Current Position</h3>
            <div class="info-item">
                <span class="info-label">Latitude:</span>
                <span class="info-value position-display" id="currentLat">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">Longitude:</span>
                <span class="info-value position-display" id="currentLng">-</span>
            </div>
        </div>

        <div class="info-group">
            <h3>Save Station Position</h3>
            <label class="info-label">Select Station:</label>
            <select class="timetable-dropdown" id="stationDropdown">
                <option value="">-- Start recording first --</option>
            </select>
            <div class="controls-row">
                <button class="btn-success" id="saveBtn" onclick="saveToTimetable()" disabled>Save Position</button>
            </div>
        </div>

        <div class="dev-tools" style="background: rgba(255, 0, 0, 0.15); border: 2px solid rgba(255, 0, 0, 0.4); border-radius: 6px; padding: 12px; margin-bottom: 12px;">
            <h3 style="color: #cc0000; margin: 0 0 10px 0; font-size: 14px;">Development Tools</h3>

            <div style="margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 0, 0, 0.3);">
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleLoadFile()">
                    <label style="font-size: 12px; color: #aaa; font-weight: 600; cursor: pointer;">Load Recording File</label>
                    <span id="loadFileToggle" style="font-size: 12px; color: #aaa;">▼</span>
                </div>
                <div id="loadFileContent" style="margin-top: 10px;">
                    <select class="timetable-dropdown" id="recordingFileSelect">
                        <option value="">-- Loading... --</option>
                    </select>
                    <div class="controls-row">
                        <button class="btn-warning" id="loadFileBtn" onclick="loadSelectedFile()">Load File</button>
                        <input type="file" id="browseFileInput" accept=".json" style="display: none;" onchange="handleFileBrowse(event)">
                        <button class="btn-secondary" onclick="document.getElementById('browseFileInput').click()">Browse...</button>
                    </div>
                    <div id="loadFileStatus" style="margin-top: 8px; font-size: 12px; color: #aaa;"></div>
                </div>
            </div>

            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" onclick="toggleCoordinatesPicker()">
                    <label style="font-size: 12px; color: #aaa; font-weight: 600; cursor: pointer;">Coordinates Picker</label>
                    <span id="coordsToggle" style="font-size: 12px; color: #aaa;">▼</span>
                </div>
                <div id="coordsPickerContent" style="margin-top: 10px;">
                    <div style="font-size: 11px; color: #888; margin-bottom: 8px;">Click on map to capture coordinates</div>
                    <div id="pickedCoords" style="font-family: 'Courier New', monospace; font-size: 12px; color: #333; background: #f8f9fa; padding: 8px; border-radius: 4px; min-height: 40px; white-space: pre-wrap;">No coordinates selected</div>
                    <div class="controls-row">
                        <button class="btn-primary" onclick="copyPickedCoords(event)">Copy</button>
                        <button class="btn-secondary" onclick="clearPickedCoords()">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="legend">
            <h3>Map Legend</h3>
            <div class="legend-item">
                <div class="legend-line" style="background: #0066ff;"></div>
                <span>Route Path</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffa500;"></div>
                <span>Current Train Position</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00cc66;"></div>
                <span>Saved Station</span>
            </div>
            <button class="follow-btn" id="followBtn" onclick="toggleFollowTrain()">Follow Train</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize the map
        const map = L.map('map').setView([52.0, -0.5], 10);

        // Add tile layers
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        });
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri',
            maxZoom: 19
        });
        osm.addTo(map);
        L.control.layers({ 'Geographic': osm, 'Satellite': satellite }).addTo(map);

        // State
        let pathCoordinates = [];
        let pathPolyline = null;
        let trainMarker = null;
        let stationMarkers = new Map();
        let isFollowingTrain = false;
        let firstPosition = true;
        let currentTimetableId = null;
        let nextStationIndex = null; // Used to advance dropdown after save
        let recordingMode = 'automatic'; // 'manual' or 'automatic'
        let pendingRawFileDelete = null; // Raw file to delete after DB save (normal mode)

        // Create custom train icon
        const trainIcon = L.divIcon({
            className: 'train-icon',
            html: '<div style="background: #ffa500; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(255,165,0,0.8), 0 2px 6px rgba(0,0,0,0.3);"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        // Store all timetables for filtering
        let allTimetables = [];
        let allRoutesWithTimetables = [];
        let routeHighlightedIndex = -1;

        // Load routes that have timetables for selector
        async function loadRoutesWithTimetables() {
            try {
                // Load all timetables first
                const timetablesResponse = await fetch('/api/timetables');
                allTimetables = await timetablesResponse.json();

                // Get unique route IDs that have timetables
                const routeIdsWithTimetables = [...new Set(allTimetables.map(t => t.route_id))];

                if (routeIdsWithTimetables.length === 0) {
                    document.getElementById('routeInput').placeholder = 'No routes with timetables';
                    return;
                }

                // Load all routes
                const routesResponse = await fetch('/api/routes');
                const allRoutes = await routesResponse.json();

                // Filter to only routes that have timetables
                allRoutesWithTimetables = allRoutes.filter(r => routeIdsWithTimetables.includes(r.id));

                // Setup the typeahead
                setupRouteTypeahead();
                console.log('Routes with timetables loaded:', allRoutesWithTimetables.length);
            } catch (err) {
                console.error('Failed to load routes:', err);
            }
        }

        // Setup typeahead for route input
        function setupRouteTypeahead() {
            const input = document.getElementById('routeInput');
            const dropdown = document.getElementById('routeDropdown');
            const hiddenSelect = document.getElementById('routeSelect');

            // Show dropdown on focus
            input.addEventListener('focus', function() {
                showRouteDropdown(this.value);
            });

            // Filter on input
            input.addEventListener('input', function() {
                routeHighlightedIndex = -1;
                hiddenSelect.value = '';
                showRouteDropdown(this.value);
            });

            // Keyboard navigation
            input.addEventListener('keydown', function(e) {
                const items = dropdown.querySelectorAll('.typeahead-item[data-id]');

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    routeHighlightedIndex = Math.min(routeHighlightedIndex + 1, items.length - 1);
                    updateRouteHighlight(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    routeHighlightedIndex = Math.max(routeHighlightedIndex - 1, 0);
                    updateRouteHighlight(items);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (routeHighlightedIndex >= 0 && items[routeHighlightedIndex]) {
                        items[routeHighlightedIndex].click();
                    }
                } else if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                }
            });

            // Hide dropdown on click outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.typeahead-container')) {
                    dropdown.style.display = 'none';
                }
            });
        }

        function updateRouteHighlight(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('highlighted', idx === routeHighlightedIndex);
            });
            if (routeHighlightedIndex >= 0 && items[routeHighlightedIndex]) {
                items[routeHighlightedIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function showRouteDropdown(filter) {
            const dropdown = document.getElementById('routeDropdown');
            const filterLower = (filter || '').toLowerCase();

            const filtered = allRoutesWithTimetables.filter(route =>
                route.name.toLowerCase().includes(filterLower)
            );

            if (filtered.length === 0) {
                dropdown.innerHTML = '<div class="typeahead-item" style="color: #999;">No routes found</div>';
            } else {
                dropdown.innerHTML = filtered.map(route => `
                    <div class="typeahead-item" data-id="${route.id}" data-name="${route.name}">
                        <div class="route-name">${route.name}</div>
                    </div>
                `).join('');

                // Add click handlers
                dropdown.querySelectorAll('.typeahead-item[data-id]').forEach(item => {
                    item.addEventListener('click', function() {
                        const id = this.dataset.id;
                        const name = this.dataset.name;
                        document.getElementById('routeInput').value = name;
                        document.getElementById('routeSelect').value = id;
                        dropdown.style.display = 'none';
                        loadTrainClassesForRoute(id);
                        document.getElementById('mainBtn').textContent = 'Start';
                    });
                });
            }

            dropdown.style.display = 'block';
        }

        // Load train classes for selected route (filtered to only those with timetables)
        async function loadTrainClassesForRoute(routeId) {
            const trainClassSelect = document.getElementById('trainClassSelect');
            const trainSelect = document.getElementById('trainSelect');
            const timetableSelect = document.getElementById('timetableSelect');

            // Reset train class, train, and timetable dropdowns
            trainClassSelect.innerHTML = '<option value="">-- Loading... --</option>';
            trainClassSelect.disabled = true;
            trainSelect.innerHTML = '<option value="">-- Select a train class first --</option>';
            trainSelect.disabled = true;
            timetableSelect.innerHTML = '<option value="">-- Select a train first --</option>';
            timetableSelect.disabled = true;

            if (!routeId) {
                trainClassSelect.innerHTML = '<option value="">-- Select a route first --</option>';
                return;
            }

            try {
                // Get timetables for this route
                const timetablesForRoute = allTimetables.filter(t => t.route_id == routeId);

                // Get all train IDs that have timetables for this route
                const trainIdsWithTimetables = [...new Set(timetablesForRoute.flatMap(t => t.train_ids || (t.train_id ? [t.train_id] : [])))];

                // Load train classes for this route
                const response = await fetch('/api/routes/' + routeId + '/train-classes');
                const trainClasses = await response.json();

                // Load all trains for this route to find which classes have trains with timetables
                const trainsResponse = await fetch('/api/routes/' + routeId + '/trains');
                const allTrainsForRoute = await trainsResponse.json();

                // Find which class IDs have at least one train with a timetable
                const classIdsWithTimetables = [...new Set(
                    allTrainsForRoute
                        .filter(t => trainIdsWithTimetables.includes(t.id))
                        .map(t => t.class_id)
                )];

                // Filter train classes to only those with timetables
                const trainClassesWithTimetables = trainClasses.filter(tc => classIdsWithTimetables.includes(tc.id));

                if (trainClassesWithTimetables.length === 0) {
                    trainClassSelect.innerHTML = '<option value="">-- No train classes with timetables --</option>';
                    return;
                }

                trainClassSelect.innerHTML = '<option value="">-- Select a train class --</option>';
                trainClassesWithTimetables.forEach(tc => {
                    const option = document.createElement('option');
                    option.value = tc.id;
                    option.textContent = tc.name;
                    trainClassSelect.appendChild(option);
                });
                trainClassSelect.disabled = false;
            } catch (err) {
                console.error('Failed to load train classes:', err);
                trainClassSelect.innerHTML = '<option value="">-- Error loading train classes --</option>';
            }
        }

        // Load trains for selected train class
        async function loadTrainsForClass(routeId, classId) {
            const trainSelect = document.getElementById('trainSelect');
            const timetableSelect = document.getElementById('timetableSelect');

            // Reset train and timetable dropdowns
            trainSelect.innerHTML = '<option value="">-- Loading... --</option>';
            trainSelect.disabled = true;
            timetableSelect.innerHTML = '<option value="">-- Select a train first --</option>';
            timetableSelect.disabled = true;

            if (!classId) {
                trainSelect.innerHTML = '<option value="">-- Select a train class first --</option>';
                return;
            }

            try {
                // Load trains for this class on this route
                const response = await fetch('/api/routes/' + routeId + '/train-classes/' + classId + '/trains');
                const trains = await response.json();

                // Filter trains that have timetables for this route
                const timetablesForRoute = allTimetables.filter(t => t.route_id == routeId);
                const trainIdsWithTimetables = [...new Set(timetablesForRoute.flatMap(t => t.train_ids || (t.train_id ? [t.train_id] : [])))];

                // Filter to trains that have timetables
                const trainsWithTimetables = trains.filter(t => trainIdsWithTimetables.includes(t.id));

                if (trainsWithTimetables.length === 0) {
                    trainSelect.innerHTML = '<option value="">-- No trains with timetables in this class --</option>';
                    return;
                }

                trainSelect.innerHTML = '<option value="">-- Select a train --</option>';
                trainsWithTimetables.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t.id;
                    option.textContent = t.name;
                    trainSelect.appendChild(option);
                });
                trainSelect.disabled = false;
            } catch (err) {
                console.error('Failed to load trains:', err);
                trainSelect.innerHTML = '<option value="">-- Error loading trains --</option>';
            }
        }

        // Load timetables for selected route and train
        function loadTimetablesForRouteAndTrain(routeId, trainId) {
            const timetableSelect = document.getElementById('timetableSelect');

            if (!routeId || !trainId) {
                timetableSelect.innerHTML = '<option value="">-- Select a train first --</option>';
                timetableSelect.disabled = true;
                return;
            }

            // Filter timetables for this route that have this train
            // Timetables now have train_ids array (or legacy train_id)
            const timetables = allTimetables.filter(t => {
                if (t.route_id != routeId) return false;
                // Check if train is in train_ids array or matches legacy train_id
                if (t.train_ids && Array.isArray(t.train_ids)) {
                    return t.train_ids.includes(parseInt(trainId));
                }
                return t.train_id == trainId;
            });

            if (timetables.length === 0) {
                timetableSelect.innerHTML = '<option value="">-- No timetables found --</option>';
                timetableSelect.disabled = true;
                return;
            }

            timetableSelect.innerHTML = '<option value="">-- Select a timetable --</option>';
            timetables.forEach(t => {
                const option = document.createElement('option');
                option.value = t.id;
                option.textContent = t.service_name;
                timetableSelect.appendChild(option);
            });
            timetableSelect.disabled = false;
        }

        // Event listeners for cascading dropdowns
        // Note: Route selection is handled by typeahead click handlers in showRouteDropdown()

        document.getElementById('trainClassSelect').addEventListener('change', function() {
            const routeId = document.getElementById('routeSelect').value;
            const classId = this.value;
            loadTrainsForClass(routeId, classId);
            document.getElementById('mainBtn').textContent = 'Start';
        });

        document.getElementById('trainSelect').addEventListener('change', function() {
            const routeId = document.getElementById('routeSelect').value;
            const trainId = this.value;
            loadTimetablesForRouteAndTrain(routeId, trainId);
            document.getElementById('mainBtn').textContent = 'Start';
        });


        // Load route data (called at init and after saves to sync with backend state)
        async function loadRouteData() {
            try {
                const response = await fetch('/api/recording/route-data');
                const data = await response.json();

                // Load existing path from backend (only at init or after resume)
                if (data.coordinates && data.coordinates.length > 0) {
                    pathCoordinates = data.coordinates.map(c => [c.latitude, c.longitude]);
                    document.getElementById('coordCount').textContent = pathCoordinates.length;

                    if (pathPolyline) {
                        pathPolyline.setLatLngs(pathCoordinates);
                    } else {
                        pathPolyline = L.polyline(pathCoordinates, {
                            color: '#0066ff',
                            weight: 4,
                            opacity: 0.7
                        }).addTo(map);
                    }

                    // Center on last known position
                    if (firstPosition && pathCoordinates.length > 0) {
                        const last = pathCoordinates[pathCoordinates.length - 1];
                        map.setView(last, 15);
                        firstPosition = false;
                    }
                }

                // Populate station dropdown and add saved station markers
                if (data.timetable && data.timetable.length > 0) {
                    // Select next unsaved station on initial load
                    populateStationDropdown(data.timetable, true);

                    // Add markers for stations with saved coordinates
                    data.timetable.forEach((entry, index) => {
                        if (entry.latitude && entry.longitude) {
                            addStationMarker(index, entry.latitude, entry.longitude, entry.destination);
                        }
                    });
                }
            } catch (err) {
                console.error('Failed to load route data:', err);
            }
        }

        // Populate station dropdown - preserves current selection or selects next unsaved
        function populateStationDropdown(timetable, selectNextUnsaved = false) {
            const dropdown = document.getElementById('stationDropdown');
            const currentValue = dropdown.value; // Preserve current selection

            dropdown.innerHTML = '';
            let firstUnsavedIndex = null;

            timetable.forEach((entry, index) => {
                const option = document.createElement('option');
                option.value = index;
                const hasCoords = entry.latitude && entry.longitude;
                option.textContent = `${index + 1}. ${entry.destination}${hasCoords ? ' [SAVED]' : ''}`;
                dropdown.appendChild(option);

                // Track the first unsaved station
                if (firstUnsavedIndex === null && !hasCoords) {
                    firstUnsavedIndex = index;
                }
            });

            // If we need to advance to next station after a save
            if (nextStationIndex !== null && nextStationIndex < timetable.length) {
                dropdown.value = nextStationIndex;
                nextStationIndex = null; // Reset the flag
            }
            // If explicitly selecting next unsaved (e.g., on initial load)
            else if (selectNextUnsaved && firstUnsavedIndex !== null) {
                dropdown.value = firstUnsavedIndex;
            }
            // Otherwise restore previous selection if it was valid
            else if (currentValue !== '' && currentValue !== null && parseInt(currentValue) < timetable.length) {
                dropdown.value = currentValue;
            }
            // Default: select the first unsaved if no previous selection
            else if (firstUnsavedIndex !== null) {
                dropdown.value = firstUnsavedIndex;
            }
        }

        // Add station marker to map
        function addStationMarker(index, lat, lng, destination) {
            if (stationMarkers.has(index)) {
                map.removeLayer(stationMarkers.get(index));
            }

            const stationIcon = L.divIcon({
                className: 'station-marker',
                html: '<div style="background-color: #00cc66; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });

            const marker = L.marker([lat, lng], { icon: stationIcon })
                .bindPopup(`<strong>${index + 1}. ${destination}</strong><br>Lat: ${lat}<br>Lng: ${lng}`)
                .addTo(map);

            stationMarkers.set(index, marker);
        }

        // Handle recording mode change (manual/automatic)
        async function handleModeChange(mode) {
            recordingMode = mode;

            // Update UI
            const infoDiv = document.getElementById('autoModeInfo');
            if (mode === 'automatic') {
                infoDiv.style.display = 'block';
            } else {
                infoDiv.style.display = 'none';
            }

            // Send mode change to backend
            try {
                const response = await fetch('/api/recording/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: mode })
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`Recording mode set to: ${mode}`);
                } else {
                    console.error('Failed to set recording mode:', result.error);
                }
            } catch (err) {
                console.error('Error setting recording mode:', err);
            }
        }

        // Load current recording mode from backend (defaults to automatic if not set)
        async function loadRecordingMode() {
            try {
                const response = await fetch('/api/recording/mode');
                const result = await response.json();
                // Always default to automatic if mode is not explicitly set
                recordingMode = result.mode || 'automatic';

                // Update radio buttons
                const radioButtons = document.querySelectorAll('input[name="recordMode"]');
                radioButtons.forEach(radio => {
                    radio.checked = (radio.value === recordingMode);
                });

                // Update info div
                const infoDiv = document.getElementById('autoModeInfo');
                infoDiv.style.display = recordingMode === 'automatic' ? 'block' : 'none';
            } catch (err) {
                console.error('Error loading recording mode:', err);
                // On error, keep the default (automatic)
            }
        }

        // Main button handler - handles Start, Resume, and Pause states
        // Button states:
        // - "Start": No recording, no incomplete file - starts fresh recording
        // - "Resume": No recording, but incomplete file exists - resumes from file
        // - "Pause": Recording is active - pauses the recording
        // - "Resume": Recording is paused - resumes the paused recording
        async function handleMainButton() {
            const mainBtn = document.getElementById('mainBtn');
            const btnText = mainBtn.textContent;

            console.log(`Main button clicked: "${btnText}", state: ${currentRecordingState}`);

            // If recording is active (button shows "Pause"), pause the recording
            if (currentRecordingState === 'recording') {
                try {
                    const response = await fetch('/api/recording/pause', { method: 'POST' });
                    const result = await response.json();
                    if (!result.success) {
                        alert('Failed to pause: ' + result.error);
                    }
                    // Stream will update the UI
                } catch (err) {
                    alert('Error pausing: ' + err.message);
                }
                return;
            }

            // If recording is paused, resume it
            if (currentRecordingState === 'paused') {
                try {
                    const response = await fetch('/api/recording/resume', { method: 'POST' });
                    const result = await response.json();
                    if (!result.success) {
                        alert('Failed to resume: ' + result.error);
                    }
                    // Stream will update the UI
                } catch (err) {
                    alert('Error resuming: ' + err.message);
                }
                return;
            }

            // Otherwise, we're starting or resuming from file (state is 'stopped')
            const timetableId = document.getElementById('timetableSelect').value;
            if (!timetableId) {
                alert('Please select a timetable first');
                return;
            }

            const isResumeFromFile = btnText === 'Resume';

            try {
                const response = await fetch(`/api/recording/start/${timetableId}`, { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    if (isResumeFromFile) {
                        // Resuming from file - show popup and DON'T clear existing data
                        alert(`Recording resumed!\n\nExisting data: ${result.coordinateCount} coordinates, ${result.markerCount} markers\n\nNew coordinates will be added to the recording.`);
                    } else {
                        // Fresh start - clear local display
                        pathCoordinates = [];
                        if (pathPolyline) {
                            map.removeLayer(pathPolyline);
                            pathPolyline = null;
                        }
                        // Clear station markers
                        stationMarkers.forEach(m => map.removeLayer(m));
                        stationMarkers.clear();
                    }
                    // Stream will update the rest

                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                } else {
                    alert('Failed to start recording: ' + result.error);
                }
            } catch (err) {
                alert('Error starting recording: ' + err.message);
            }
        }

        // Track current recording state for button logic
        // 'stopped' = not recording (can start fresh or resume from file)
        // 'recording' = actively recording (can pause)
        // 'paused' = recording paused (can resume)
        let currentRecordingState = 'stopped';

        // Stop recording, process file, and save to database
        async function stopRecording() {
            const stopBtn = document.getElementById('stopBtn');
            stopBtn.disabled = true;
            stopBtn.textContent = 'Stopping...';

            try {
                // Step 1: Stop the recording and process it (combined in backend)
                const stopResponse = await fetch('/api/recording/stop', { method: 'POST' });
                const stopResult = await stopResponse.json();

                if (!stopResult.success) {
                    throw new Error(stopResult.error || 'Failed to stop recording');
                }

                console.log('Recording stopped and processed:', stopResult);

                // Check if processing failed
                if (stopResult.processingError) {
                    alert(`Recording stopped but processing failed:\n${stopResult.processingError}`);
                    await loadRecordingFiles();
                    return;
                }

                // Step 2: Save the processed JSON to the database
                stopBtn.textContent = 'Saving to DB...';

                const saveResponse = await fetch('/api/map/save-processed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: stopResult.processedFile })
                });

                const saveResult = await saveResponse.json();

                if (!saveResult.success) {
                    throw new Error(saveResult.error || 'Failed to save to database');
                }

                console.log('Saved to database:', saveResult);

                // Step 3: Handle file management (delete raw file in normal mode)
                if (stopResult.fileManagement && stopResult.fileManagement.action === 'pending_delete') {
                    try {
                        const rawFile = stopResult.fileManagement.rawFile;
                        const deleteResponse = await fetch(`/api/recording/delete-file/${encodeURIComponent(rawFile)}`, {
                            method: 'DELETE'
                        });
                        const deleteResult = await deleteResponse.json();
                        if (deleteResult.success) {
                            console.log('Raw file deleted:', rawFile);
                        } else {
                            console.warn('Failed to delete raw file:', deleteResult.error);
                        }
                    } catch (deleteErr) {
                        console.warn('Error deleting raw file:', deleteErr);
                    }
                }

                // Build alert message with stop detection info
                let alertMsg = `Processing and save complete!\n\n` +
                    `Output: ${stopResult.processedFile}\n` +
                    `Coordinates: ${saveResult.coordinateCount}\n` +
                    `Markers: ${saveResult.markerCount}\n` +
                    `Entry updates: ${saveResult.entryUpdates}`;

                if (stopResult.processedStats && stopResult.processedStats.detectedStops > 0) {
                    alertMsg += `\nAuto-detected stops: ${stopResult.processedStats.detectedStops}`;
                }

                if (stopResult.fileManagement) {
                    if (stopResult.fileManagement.action === 'moved_to_saved') {
                        alertMsg += `\n\nDev mode: Raw data saved to saved_raw_data/`;
                    } else if (stopResult.fileManagement.action === 'pending_delete') {
                        alertMsg += `\n\nRaw recording file cleaned up`;
                    }
                }

                alert(alertMsg);

                // Refresh recording files dropdown
                await loadRecordingFiles();

            } catch (err) {
                console.error('Error processing/saving recording:', err);
                alert('Error: ' + err.message);
            } finally {
                stopBtn.textContent = 'Save';
                stopBtn.disabled = false;
            }
        }

        // Reset recording - clears all state for testing
        async function resetRecording() {
            if (!confirm('Reset all recording state? This will clear coordinates, markers, and saved positions.')) {
                return;
            }

            try {
                const response = await fetch('/api/recording/reset', { method: 'POST' });
                const result = await response.json();
                if (result.success) {
                    // Clear local state
                    pathCoordinates = [];
                    if (pathPolyline) {
                        map.removeLayer(pathPolyline);
                        pathPolyline = null;
                    }
                    // Clear station markers
                    stationMarkers.forEach(m => map.removeLayer(m));
                    stationMarkers.clear();
                    // Reset UI
                    currentTimetableId = null;
                    currentRecordingState = 'stopped';
                    document.getElementById('coordCount').textContent = '0';
                    document.getElementById('stationDropdown').innerHTML = '<option value="">-- Start recording first --</option>';
                    // Reset all cascading dropdowns
                    document.getElementById('routeSelect').value = '';
                    document.getElementById('trainClassSelect').innerHTML = '<option value="">-- Select a route first --</option>';
                    document.getElementById('trainClassSelect').disabled = true;
                    document.getElementById('trainSelect').innerHTML = '<option value="">-- Select a train class first --</option>';
                    document.getElementById('trainSelect').disabled = true;
                    document.getElementById('timetableSelect').innerHTML = '<option value="">-- Select a train first --</option>';
                    document.getElementById('timetableSelect').disabled = true;
                    // Reset main button
                    const mainBtn = document.getElementById('mainBtn');
                    mainBtn.textContent = 'Start';
                    mainBtn.className = 'btn-success';
                    mainBtn.disabled = false;
                    // Reset dev tools status
                    const statusEl = document.getElementById('loadFileStatus');
                    if (statusEl) {
                        statusEl.textContent = '';
                    }
                    // Update UI state
                    updateUIFromRecording({ isRecording: false, isPaused: false });
                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                    console.log('Recording state reset');
                } else {
                    alert('Failed to reset: ' + result.error);
                }
            } catch (err) {
                alert('Error resetting: ' + err.message);
            }
        }

        // Save current position to timetable
        async function saveToTimetable() {
            const index = parseInt(document.getElementById('stationDropdown').value);
            const latEl = document.getElementById('currentLat');
            const lngEl = document.getElementById('currentLng');

            // Use full precision values stored in dataset, not truncated display text
            const lat = latEl.dataset.fullValue;
            const lng = lngEl.dataset.fullValue;

            if (!lat || !lng || latEl.textContent === '-') {
                alert('No current position available');
                return;
            }

            try {
                const response = await fetch('/api/recording/save-timetable-coords', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        index: index,
                        latitude: parseFloat(lat),
                        longitude: parseFloat(lng)
                    })
                });
                const result = await response.json();
                if (result.success) {
                    // Set flag to advance to next station
                    const dropdown = document.getElementById('stationDropdown');
                    if (index + 1 < dropdown.options.length) {
                        nextStationIndex = index + 1;
                    }
                    // Stream will update the timetable with saved coords
                } else {
                    alert('Failed to save: ' + result.error);
                }
            } catch (err) {
                alert('Error saving: ' + err.message);
            }
        }

        // Toggle follow train
        function toggleFollowTrain() {
            const btn = document.getElementById('followBtn');
            isFollowingTrain = !isFollowingTrain;

            if (isFollowingTrain) {
                btn.textContent = 'Stop Following';
                btn.classList.add('following');
                if (trainMarker) {
                    const pos = trainMarker.getLatLng();
                    map.setView([pos.lat, pos.lng], map.getZoom());
                }
            } else {
                btn.textContent = 'Follow Train';
                btn.classList.remove('following');
            }
        }

        // SSE stream connection
        let eventSource = null;

        function connectToStream() {
            if (eventSource) {
                eventSource.close();
            }

            console.log('Connecting to telemetry stream...');
            eventSource = new EventSource('/stream');

            eventSource.onopen = () => {
                console.log('SSE connection established');
            };

            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleStreamData(data);
                } catch (err) {
                    console.error('Failed to parse stream data:', err);
                }
            };

            eventSource.onerror = (err) => {
                console.error('SSE connection error:', err);
                // Reconnect after 2 seconds
                setTimeout(connectToStream, 2000);
            };
        }

        // Handle incoming stream data
        function handleStreamData(data) {
            // Update current position display
            if (data.playerPosition) {
                const lat = data.playerPosition.latitude;
                const lng = data.playerPosition.longitude;

                // Validate coordinates - skip if they're invalid (0,0 or not real numbers)
                // Also filter out TSW cached/stale position when game not active
                const isStalePosition = lat === 51.380108707397724 && lng === 0.5219243867730494;
                const isValidCoord = typeof lat === 'number' && typeof lng === 'number' &&
                                     !isNaN(lat) && !isNaN(lng) &&
                                     (lat !== 0 || lng !== 0) &&
                                     !isStalePosition &&
                                     lat >= -90 && lat <= 90 &&
                                     lng >= -180 && lng <= 180;

                if (isValidCoord) {
                    // Store full precision for saving, display truncated
                    document.getElementById('currentLat').textContent = lat.toFixed(6);
                    document.getElementById('currentLng').textContent = lng.toFixed(6);
                    document.getElementById('currentLat').dataset.fullValue = lat;
                    document.getElementById('currentLng').dataset.fullValue = lng;

                    // Update train marker
                    if (trainMarker) {
                        trainMarker.setLatLng([lat, lng]);
                    } else {
                        trainMarker = L.marker([lat, lng], { icon: trainIcon })
                            .bindPopup('Current Position')
                            .addTo(map);
                    }

                    // Add to path display if recording (for visual feedback)
                    // The backend is the source of truth, we just add points for smooth display
                    if (currentTimetableId && data.recording && data.recording.isRecording && !data.recording.isPaused) {
                        const newPoint = [lat, lng];
                        pathCoordinates.push(newPoint);

                        if (pathPolyline) {
                            pathPolyline.addLatLng(newPoint);
                        } else {
                            pathPolyline = L.polyline(pathCoordinates, {
                                color: '#0066ff',
                                weight: 4,
                                opacity: 0.7
                            }).addTo(map);
                        }
                    }

                    // Center on first position or follow train
                    if (firstPosition) {
                        map.setView([lat, lng], 15);
                        firstPosition = false;
                    } else if (isFollowingTrain) {
                        map.setView([lat, lng], map.getZoom());
                    }
                } else {
                    // Reset display when coordinates are invalid (game not running)
                    document.getElementById('currentLat').textContent = '-';
                    document.getElementById('currentLng').textContent = '-';
                    document.getElementById('currentLat').dataset.fullValue = '';
                    document.getElementById('currentLng').dataset.fullValue = '';

                    // Remove train marker if it exists
                    if (trainMarker) {
                        map.removeLayer(trainMarker);
                        trainMarker = null;
                    }
                }
            }

            // Update recording state from stream
            if (data.recording) {
                currentTimetableId = data.recording.timetableId;
                document.getElementById('coordCount').textContent = data.recording.coordinateCount || 0;

                // Check for auto-stop trigger
                if (data.recording.autoStopped) {
                    console.log('Auto-stop triggered by backend');
                    alert('Recording auto-stopped after 4 minutes of no movement.\nSaving to database...');
                    // Trigger the save sequence
                    stopRecording();
                    return;
                }

                // Update UI state
                updateUIFromRecording(data.recording);

                // Update timetable dropdown and station markers
                if (data.recording.timetable && data.recording.timetable.length > 0) {
                    populateStationDropdown(data.recording.timetable);

                    // Add markers for stations with saved coordinates
                    data.recording.timetable.forEach((entry, index) => {
                        if (entry.latitude && entry.longitude) {
                            addStationMarker(index, entry.latitude, entry.longitude, entry.destination);
                        }
                    });
                }
            } else if (currentTimetableId) {
                // Recording stopped - clear state
                currentTimetableId = null;
                updateUIFromRecording({ isRecording: false, isPaused: false });
            }
        }

        // Update UI based on recording state from stream
        function updateUIFromRecording(recording) {
            const indicator = document.getElementById('recordingIndicator');
            const text = document.getElementById('recordingText');
            const mainBtn = document.getElementById('mainBtn');
            const stopBtn = document.getElementById('stopBtn');
            const saveBtn = document.getElementById('saveBtn');

            if (recording.isRecording && !recording.isPaused) {
                // Recording is active
                currentRecordingState = 'recording';
                indicator.className = 'recording-indicator';
                text.textContent = 'Recording';
                mainBtn.textContent = 'Pause';
                mainBtn.className = 'btn-warning';
                mainBtn.disabled = false;
                stopBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
            } else if (recording.isPaused) {
                // Recording is paused
                currentRecordingState = 'paused';
                indicator.className = 'recording-indicator paused';
                text.textContent = 'Paused';
                mainBtn.textContent = 'Resume';
                mainBtn.className = 'btn-success';
                mainBtn.disabled = false;
                stopBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
            } else {
                // Not recording - check if there's an incomplete file to resume
                currentRecordingState = 'stopped';
                indicator.className = 'recording-indicator stopped';
                text.textContent = 'Not Recording';
                // Button text (Start vs Resume) is set by checkForExistingRecording
                // Keep current text if it's already "Resume", otherwise default to "Start"
                if (mainBtn.textContent !== 'Resume') {
                    mainBtn.textContent = 'Start';
                }
                mainBtn.className = 'btn-success';
                mainBtn.disabled = false;
                stopBtn.disabled = true;
                if (saveBtn) saveBtn.disabled = true;
            }
        }

        // Load config and hide dev tools if needed
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                if (!config.developmentMode) {
                    const devTools = document.querySelector('.dev-tools');
                    if (devTools) {
                        devTools.style.display = 'none';
                    }
                    // Adjust panel to be shorter and further from top when not in dev mode
                    const infoPanel = document.querySelector('.info-panel');
                    if (infoPanel) {
                        infoPanel.style.top = '80px';
                        infoPanel.style.bottom = 'auto';
                    }
                }
            } catch (err) {
                console.error('Failed to load config:', err);
            }
        }

        // Load recording files list for the dev tools dropdown
        async function loadRecordingFiles() {
            const select = document.getElementById('recordingFileSelect');
            select.innerHTML = '<option value="">-- Loading... --</option>';

            try {
                const response = await fetch('/api/recording/list');
                const files = await response.json();

                select.innerHTML = '<option value="">-- Select a file --</option>';
                files.forEach(f => {
                    const option = document.createElement('option');
                    option.value = f.filename;
                    option.textContent = `${f.routeName} (${f.coordinateCount} pts) - ${f.filename}`;
                    select.appendChild(option);
                });

                if (files.length === 0) {
                    select.innerHTML = '<option value="">-- No recording files --</option>';
                }
            } catch (err) {
                console.error('Failed to load recording files:', err);
                select.innerHTML = '<option value="">-- Error loading --</option>';
            }
        }

        // Load selected file from dropdown
        async function loadSelectedFile() {
            const select = document.getElementById('recordingFileSelect');
            const filename = select.value;
            const statusEl = document.getElementById('loadFileStatus');

            if (!filename) {
                statusEl.textContent = 'Please select a file first';
                statusEl.style.color = '#e94560';
                return;
            }

            await loadRecordingFileByName(filename);
        }

        // Handle file browse input
        async function handleFileBrowse(event) {
            const file = event.target.files[0];
            if (!file) return;

            const statusEl = document.getElementById('loadFileStatus');
            statusEl.textContent = 'Reading file...';
            statusEl.style.color = '#aaa';

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.timetableId) {
                    statusEl.textContent = 'Error: File does not contain timetableId';
                    statusEl.style.color = '#e94560';
                    return;
                }

                // Upload the file to the server first, then load it
                // For now, we'll use the file directly if it matches an existing file
                // or show an error
                statusEl.textContent = `File: ${file.name} (timetable ${data.timetableId})`;
                statusEl.style.color = '#28a745';

                // Check if this file exists on server
                const response = await fetch(`/api/recording/file?file=${encodeURIComponent(file.name)}`);
                if (response.ok) {
                    await loadRecordingFileByName(file.name);
                } else {
                    statusEl.innerHTML = `<span style="color: #ffc107;">File not on server.</span> Copy to recording_data folder first.`;
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e94560';
            }

            // Reset file input
            event.target.value = '';
        }

        // Load a recording file by name
        async function loadRecordingFileByName(filename) {
            const statusEl = document.getElementById('loadFileStatus');
            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#aaa';

            try {
                const response = await fetch(`/api/recording/load-file?file=${encodeURIComponent(filename)}`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    statusEl.innerHTML = `<span style="color: #28a745;">Loaded!</span> ${result.coordinateCount} coords, ${result.markerCount} markers`;

                    // Update the cascading dropdowns to match the timetable
                    await selectTimetableById(result.timetableId);

                    // Update UI to show paused state (enables Save button)
                    updateUIFromRecording({ isRecording: true, isPaused: true });

                    // Load the route data to display on map
                    await loadRouteData();

                    // Refresh recording files dropdown
                    await loadRecordingFiles();
                } else {
                    statusEl.textContent = 'Error: ' + result.error;
                    statusEl.style.color = '#e94560';
                }
            } catch (err) {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e94560';
            }
        }

        // Check for existing recording when timetable is selected
        async function checkForExistingRecording(timetableId) {
            if (!timetableId) return;

            try {
                const response = await fetch(`/api/recording/check-existing/${timetableId}`);
                const result = await response.json();

                const mainBtn = document.getElementById('mainBtn');

                if (result.exists) {
                    mainBtn.textContent = 'Resume';
                    console.log(`Found existing recording: ${result.filename} with ${result.coordinateCount} coordinates`);
                } else {
                    mainBtn.textContent = 'Start';
                }
            } catch (err) {
                console.error('Error checking for existing recording:', err);
            }
        }

        // Add event listener for timetable select change
        document.getElementById('timetableSelect').addEventListener('change', async function() {
            const timetableId = this.value;
            if (timetableId) {
                checkForExistingRecording(timetableId);
                // Load timetable data from database and display station markers
                await loadTimetableFromDb(timetableId);
            } else {
                document.getElementById('mainBtn').textContent = 'Start';
                // Clear station markers
                stationMarkers.forEach(m => map.removeLayer(m));
                stationMarkers.clear();
            }
        });

        // Load timetable entries from database and display station markers
        async function loadTimetableFromDb(timetableId) {
            try {
                const response = await fetch(`/api/map/route-data/${timetableId}`);
                const data = await response.json();

                console.log('Timetable data from DB:', data.timetable);

                // Clear existing station markers
                stationMarkers.forEach(m => map.removeLayer(m));
                stationMarkers.clear();

                // Populate station dropdown and add markers
                if (data.timetable && data.timetable.length > 0) {
                    populateStationDropdown(data.timetable, true);

                    // Add markers for stations with coordinates
                    data.timetable.forEach((entry, index) => {
                        if (entry.latitude && entry.longitude) {
                            addStationMarker(index, entry.latitude, entry.longitude, entry.destination);
                        }
                    });

                    // Load coordinates if available
                    if (data.coordinates && data.coordinates.length > 0) {
                        pathCoordinates = data.coordinates.map(c => [c.latitude, c.longitude]);
                        document.getElementById('coordCount').textContent = pathCoordinates.length;

                        if (pathPolyline) {
                            pathPolyline.setLatLngs(pathCoordinates);
                        } else {
                            pathPolyline = L.polyline(pathCoordinates, {
                                color: '#0066ff',
                                weight: 4,
                                opacity: 0.7
                            }).addTo(map);
                        }

                        // Center on first coordinate
                        if (pathCoordinates.length > 0) {
                            map.setView(pathCoordinates[0], 12);
                        }
                    }
                }
            } catch (err) {
                console.error('Error loading timetable from DB:', err);
            }
        }

        // Helper to select route/class/train/timetable by timetable ID
        async function selectTimetableById(timetableId) {
            // Find the timetable in our cached list
            const timetable = allTimetables.find(t => t.id == timetableId);
            if (!timetable) return false;

            // Set route dropdown and trigger train class load
            const routeSelect = document.getElementById('routeSelect');
            routeSelect.value = timetable.route_id;
            await loadTrainClassesForRoute(timetable.route_id);

            // Find the train's class
            // Get the first train from timetable (train_ids array or legacy train_id)
            const trainId = timetable.train_ids && timetable.train_ids.length > 0
                ? timetable.train_ids[0]
                : timetable.train_id;

            if (trainId) {
                try {
                    // Get the train to find its class
                    const trainResponse = await fetch('/api/trains/' + trainId);
                    const train = await trainResponse.json();

                    if (train.class_id) {
                        // Set train class dropdown and trigger train load
                        const trainClassSelect = document.getElementById('trainClassSelect');
                        trainClassSelect.value = train.class_id;
                        await loadTrainsForClass(timetable.route_id, train.class_id);

                        // Set train dropdown and trigger timetable load
                        const trainSelect = document.getElementById('trainSelect');
                        trainSelect.value = trainId;
                        loadTimetablesForRouteAndTrain(timetable.route_id, trainId);

                        // Set timetable dropdown
                        const timetableSelect = document.getElementById('timetableSelect');
                        timetableSelect.value = timetableId;

                        return true;
                    }
                } catch (err) {
                    console.error('Error getting train details:', err);
                }
            }

            return false;
        }

        // Check for any existing recording file and auto-load it
        async function checkAndLoadExistingRecording() {
            try {
                const response = await fetch('/api/recording/check-any-existing');
                const result = await response.json();

                if (result.exists && result.filename) {
                    console.log(`Found existing recording: ${result.filename}`);
                    console.log(`  Route: ${result.routeName}, Coords: ${result.coordinateCount}, Markers: ${result.markerCount}`);

                    // Auto-load the file
                    const loadResponse = await fetch(`/api/recording/load-file?file=${encodeURIComponent(result.filename)}`, {
                        method: 'POST'
                    });
                    const loadResult = await loadResponse.json();

                    if (loadResult.success) {
                        // Update the cascading dropdowns to match the timetable
                        await selectTimetableById(loadResult.timetableId);

                        // Update UI to show paused state (enables Save button)
                        updateUIFromRecording({ isRecording: true, isPaused: true });

                        // Update dev tools status
                        const statusEl = document.getElementById('loadFileStatus');
                        if (statusEl) {
                            statusEl.innerHTML = `<span style="color: #28a745;">Auto-loaded:</span> ${result.filename}`;
                        }

                        console.log(`Auto-loaded recording: ${loadResult.coordinateCount} coords, ${loadResult.markerCount} markers`);
                        return true;
                    }
                }
                return false;
            } catch (err) {
                console.error('Error checking for existing recording:', err);
                return false;
            }
        }

        // Coordinates picker state
        let pickedLat = null;
        let pickedLng = null;
        let coordsPickerMarker = null;

        // Toggle load file section visibility
        function toggleLoadFile() {
            const content = document.getElementById('loadFileContent');
            const toggle = document.getElementById('loadFileToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Toggle coordinates picker visibility
        function toggleCoordinatesPicker() {
            const content = document.getElementById('coordsPickerContent');
            const toggle = document.getElementById('coordsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        // Map click handler for coordinates picker
        function setupCoordinatesPicker() {
            map.on('click', function(e) {
                pickedLat = e.latlng.lat;
                pickedLng = e.latlng.lng;
                updatePickedCoords();

                // Add or move marker
                if (coordsPickerMarker) {
                    coordsPickerMarker.setLatLng(e.latlng);
                } else {
                    const pickerIcon = L.divIcon({
                        className: 'picker-marker',
                        html: '<div style="background: #ff00ff; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 8px rgba(255,0,255,0.6);"></div>',
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    });
                    coordsPickerMarker = L.marker(e.latlng, { icon: pickerIcon }).addTo(map);
                }
            });
        }

        // Update picked coordinates display
        function updatePickedCoords() {
            const display = document.getElementById('pickedCoords');
            if (pickedLat !== null && pickedLng !== null) {
                display.textContent = `Latitude: ${pickedLat}\nLongitude: ${pickedLng}`;
            } else {
                display.textContent = 'No coordinates selected';
            }
        }

        // Copy picked coordinates in JSON format
        function copyPickedCoords(e) {
            if (pickedLat === null || pickedLng === null) {
                alert('No coordinates to copy. Click on the map first.');
                return;
            }
            const text = `"longitude": ${pickedLng},\n"latitude": ${pickedLat},`;
            const btn = e ? e.target : document.querySelector('#coordsPickerContent .btn-primary');
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback - still show success if text was likely copied
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
            });
        }

        // Clear picked coordinates
        function clearPickedCoords() {
            pickedLat = null;
            pickedLng = null;
            updatePickedCoords();
            if (coordsPickerMarker) {
                map.removeLayer(coordsPickerMarker);
                coordsPickerMarker = null;
            }
        }

        // Initialize
        async function initialize() {
            await loadRoutesWithTimetables();

            // Setup coordinates picker click handler
            setupCoordinatesPicker();

            // Check for any existing recording file and auto-load it
            const hasExisting = await checkAndLoadExistingRecording();

            // Load existing recording data if any (for path display)
            await loadRouteData();

            // Load recording files for dev tools
            await loadRecordingFiles();

            // Load config to hide dev tools if needed
            await loadConfig();

            // Load recording mode setting
            await loadRecordingMode();

            // Check URL parameters for pre-selected timetable
            const urlParams = new URLSearchParams(window.location.search);
            const timetableIdParam = urlParams.get('timetable_id');
            const routeId = urlParams.get('route_id');
            const trainId = urlParams.get('train_id');

            // If we have a timetable_id param, select it directly
            if (timetableIdParam) {
                console.log(`Record map opened with timetable_id=${timetableIdParam}`);
                const selected = await selectTimetableById(parseInt(timetableIdParam));
                if (selected) {
                    // Load the timetable data for the map
                    await loadTimetableFromDb(timetableIdParam);
                }
            } else if (routeId || trainId) {
                // If we have route/train params, try to find a matching timetable
                console.log(`Record map opened with route_id=${routeId}, train_id=${trainId}`);
            }

            // Connect to stream - all state updates come from here
            connectToStream();
        }

        initialize();
    </script>
</body>
</html>
